program superusers_karamja_fisher;

{$define SMART}
{$define _DEBUG_SURFACES}

{$i srl-6/srl.simba}
{$i srl-6/lib/misc/srlplayerform.simba}
{$i sps/lib/sps-rs3.simba}

const
  VERSION = '1.0';

type
  TSurfacePartFilterFunc = function (
    const atpa: T2DPointArray;
    const p_: TPoint;
    out index: integer
  ): TPoint;

  TSurfacePart = record
    bounds,
    size: TBox;
    color_settings: TColorSettings;
    color_tolerance,
    color,
    step,
    max_distance,
    min_pixel_count: integer;
    anti: boolean;
    p: TPoint;
    base_atpa: T2DPointArray;
  end

  TSurfacePartArray = array of ^TSurfacePart;

  TSurfaceObject = record
    name: string;
    parts: TSurfacePartArray;
    bounds: TBox;
    hits: TBoxArray;
    filter: TSurfacePartFilterFunc;
  end

  TSurfaceObjectArray = array of ^TSurfaceObject;

var
  karamja: TSPSArea;
  walking_paths: T2DPointArray;
  __surface_objects: TSurfaceObjectArray;
  fish_str: string;

procedure SUSSetup()
begin
  AddOnTerminate('SUSUninitialize');
end

procedure SUSUninitialize()
var
  i: integer;
begin
  for i := 0 to High(__surface_objects) do
    FreeMem(__surface_objects[i]);
end

function SurfaceFilterClosest(
  const atpa: T2DPointArray;
  const p_: TPoint;
  out index: integer
): TPoint
var
  i: integer;
  p: TPoint;
  c, ch: extended;
begin
  ch := $ffff;

  for i := 0 to High(atpa) do begin
    p := MiddleTPA(atpa[i]);
    c := Sqrt(Sqr(Abs(p_.x - p.x)) + Sqr(Abs(p_.y - p.y)));

    if c < ch then begin
      ch := c;
      result := p;
      index := i;
    end
  end
end

function SUSAddObject(
  const name: string;
  filter: TSurfacePartFilterFunc = @SurfaceFilterClosest
): ^TSurfaceObject
begin
  result := __surface_objects.Create(name, @filter);
end

function TSurfaceObjectArray.Create(
  const _name: string;
  _filter: TSurfacePartFilterFunc = @SurfaceFilterClosest
): ^TSurfaceObject
begin
  SetLength(self, Length(self) + 1);

  New(result);

  with result^ do begin
    name := _name;
    filter := @_filter;
  end

  self[High(self)] := result;
end

function TBox.FindColorsTPA(
  const tcs: TColorSettings;
  d, c, t: integer
): TPointArray
var
  tpa: TPointArray;
begin
  FindColorsTolerance(tpa, c, self, t, tcs);

  result := RemoveDistTPointArray(
    mainscreen.playerPoint.x,
    mainscreen.playerPoint.y,
    d,
    RemoveDistTPointArray(
      mainscreen.playerPoint.x, mainscreen.playerPoint.y, 10, tpa, false
    ),
    true
  );
end

function TPointArray.AssertBoxSize(const size: TBox): boolean
begin
  result := true;

  with GetTPABounds(self) do
    if (x2 - x1 < size.x1) or
       (x2 - x1 > size.x2) or
       (y2 - y1 < size.y1) or
       (y2 - y1 > size.y2) then
      result := false;
end

procedure T2DPointArray.DeleteIndex(index: integer)
var
  i: integer;
begin
  for i := index to High(self) - 1 do
    self[i] := self[i + 1];

  SetLength(self, Length(self) - 1);
end

function TSurfacePart.Find(
  const b: TBox;
  const f: TSurfacePartFilterFunc = @SurfaceFilterClosest
): boolean
var
  atpa, atpa_: T2DPointArray;
  i: integer;
begin
  result := false;
  atpa := SplitTPAEx(
    b.FindColorsTPA(
      self.color_settings,
      self.max_distance,
      self.color,
      self.color_tolerance
    ),
    self.step,
    self.step // TODO: Individual x/y -steps.
  );

  for i := 0 to High(atpa) do begin
    if atpa[i].AssertBoxSize(self.size) and
      (Length(atpa[i]) > self.min_pixel_count) then begin
      SetLength(atpa_, Length(atpa_) + 1);

      atpa_[High(atpa_)] := CopyTPA(atpa[i]);
    end else begin
      {$ifdef DEBUG_SURFACES}
      smartImage.drawBox(atpa[i].GetBounds(), clRed);
      {$endif}
    end
  end

  if Length(atpa_) > 0 then begin
    SetLength(self.base_atpa, 0);

    self.base_atpa := CopyATPA(atpa_);
    result := true;
  end
end

function TSurfacePartArray.Create(const csp: TSurfacePart = []): ^TSurfacePart
begin
  SetLength(self, Length(self) + 1);

  New(result);

  with result^ do begin
    base_atpa := csp.base_atpa;
    bounds := csp.bounds;
    color := csp.color;
    color_settings := csp.color_settings;
    color_tolerance := csp.color_tolerance;
    max_distance := csp.max_distance;
    min_pixel_count := csp.min_pixel_count;
    size := csp.size;
    step := csp.step;
    anti := csp.anti;
  end

  self[High(self)] := result;
end

function TSurfacePart.SetMinPixelCount(
  pixel_count: integer
): ^TSurfacePart
begin
  self.min_pixel_count := pixel_count;

  result := @self;
end

function TSurfacePart.SetAnti(
  _anti: boolean = true
): ^TSurfacePart
begin
  self.anti := _anti;

  result := @self;
end

function TSurfacePart.SetStep(
  _step: integer
): ^TSurfacePart
begin
  self.step := _step;

  result := @self;
end

function TSurfacePart.SetMaxDistance(
  distance: integer
): ^TSurfacePart
begin
  self.max_distance := distance;

  result := @self;
end

function TSurfacePart.SetSize(
  _size: TBox
): ^TSurfacePart
begin
  self.size := _size;

  result := @self;
end

function TSurfacePart.SetColorData(
  _cts,
  _color,
  _tolerance: integer;
  _hue,
  _saturation,
  _sensitivity: extended = 0.0
): ^TSurfacePart
begin
  self.color := _color;
  self.color_tolerance := _tolerance;
  self.color_settings.cts := _cts;
  self.color_settings.modifier.hue := _hue;
  self.color_settings.modifier.saturation := _saturation;
  self.color_settings.modifier.sensitivity := _sensitivity;

  result := @self;
end

function TSurfaceObject.CreatePart(): ^TSurfacePart
begin
  result := self.parts.Create();
end

function TSurfaceObject.Point(): TPoint
begin
  result := self.bounds.GetMiddle();
end

function TSurfaceObject.Find(
  const area: TBox;
  const f: TSurfacePartFilterFunc = nil
): boolean
var
  many_parts, b: boolean;
  i, k, j, mp: integer;
  o: TSurfacePartFilterFunc;
begin
  many_parts := Length(self.parts) > 1;
  result := true;
  mp := 0;

  if @f <> nil then begin
    o := @self.filter;
    self.filter := @f;
  end

  {$ifdef DEBUG_SURFACES}

  smartImage.clear();

  {$endif}

  for i := 0 to High(self.parts) do begin
    if i = 0 then
      result := self.parts[0]^.Find(area, @self.filter)
    else begin
      if not result then begin
        if @f <> nil then
          self.filter := @o;

        Exit();
      end

      if many_parts then begin
        k := High(self.parts[0]^.base_atpa);

        for j := 0 to k do begin
          {$ifdef DEBUG_SURFACES}

          smartImage.drawBox(self.parts[0]^.base_atpa[j].GetBounds(), clRed);

          {$endif}

          b := self.parts[i]^.Find(
            GetTPABounds(self.parts[0]^.base_atpa[j]),
            @self.filter
          );

          if self.parts[i]^.anti then
            b := not b

          if not b then begin
            // Remove from potential hits.
            self.parts[0]^.base_atpa.DeleteIndex(j);

            Dec(k);
            Dec(j);
          end
        end
      end
    end
  end

  if Length(self.parts[0]^.base_atpa) = 0 then begin
    if @f <> nil then
      self.filter := @o;

    Exit(false);
  end

  self.filter(self.parts[0]^.base_atpa, mainscreen.playerPoint, i);

  self.bounds := GetTPABounds(self.parts[0]^.base_atpa[i]);

  SetLength(self.hits, Length(self.parts[0]^.base_atpa));

  for i := 0 to High(self.hits) do begin
    {$ifdef DEBUG_SURFACES}

    smartImage.drawBox(self.parts[0]^.base_atpa[i].GetBounds(), clYellow);

    {$endif}

    self.hits[i] := self.parts[0]^.base_atpa[i].GetBounds();
  end

  SetLength(self.parts[0]^.base_atpa, 0);

  if @f <> nil then
    self.filter := @o;
end

function SUSGetObject(const name: string): ^TSurfaceObject
var
  i: integer;
begin
  result := nil;

  for i := 0 to High(__surface_objects) do
    if __surface_objects[i]^.name = name then
      Exit(__surface_objects[i]);
end

function MouseRandom(const p: TPoint; mouse_action: integer): TPoint
var
  mouse_style: array [0..2] of integer;
  x, y: integer;
begin
  mouse_style := [MOUSE_BREAK, MOUSE_ACCURATE, MOUSE_HUMAN];
  mouseSpeed := RandomRange(30, 38);

  if (mouse_action = MOUSE_MOVE) then
    MissMouse(p, true)
  else
    Mouse(p, mouse_action, mouse_style[Random(2)]);

  GetMousePos(x, y);

  result := TPoint([x, y]);
end

function TSurfaceObject.Click(
  tries: integer = 5;
  click_type: integer = MOUSE_LEFT;
  text: string = '';
  rotate: boolean = false;
  backup_right: boolean = false;
  search_all: boolean = false
): boolean
var
  c, i, x, y: integer = 0;
begin
  result := false;

  if tries = 0 then
    Exit();

  if self.Find(mainscreen.GetBounds()) then begin
    if search_all then
      c := High(self.hits);

    if text = '' then
      text := self.name;

    for i := 0 to c do begin
      MouseRandom(hits[i].GetMiddle(), MOUSE_MOVE);

      if (click_type = MOUSE_LEFT) and IsMouseOverText(
        [text], RandomRange(800, 1000)
      ) then begin
        FastClick(MOUSE_LEFT);

        result := true;
      end else if (backup_right) or (click_type = MOUSE_RIGHT) then begin
        FastClick(MOUSE_RIGHT);

        result := chooseOption.Select([text]);
      end

      if result then begin
        GetMousePos(x, y);
        MouseCircle(x, y, Random(100));

        minimap.WaitPlayerMoving();

        break;
      end
    end
  end

  if not result and rotate then begin
    minimap.setAngle(Random(360));

    Exit(self.Click(tries - 1, click_type, text, rotate, backup_right, search_all));
  end
end

procedure TPlayer.Configure()
begin
  disableSRLDebug := not self.booleans[0];

  if not self.Login() then
    TerminateScript();

  minimap.clickCompass();
  mainscreen.setAngle(MS_ANGLE_HIGH);

  if self.strings[1] = 'Lobster' then
    fish_str := 'age'
  else
    fish_str := 'arp';
end

procedure AssertSPSMap(path, url, name, _sha1: string)
var
  map, data: string;
  fh: LongInt;
begin
  map := AppPath + path + '/' + name + '.png';

  if FileExists(map) then begin
    fh := OpenFile(map, false);
    ReadFileString(fh, data, FileSize(fh));
    CloseFile(fh);

    if Sha1(data) = _sha1 then
      Exit();
  end

  CloseFile(CreateFile(map));

  fh := ReWriteFile(map, false);

  WriteFileString(fh, GetPage(url + '/' + name + '.png'));
  CloseFile(fh);
end

procedure Updater()
var
  version_remote, source, s: string;
  fh: LongInt;
  i: integer;
begin
  version_remote := GetPage(
    'https://raw.githubusercontent.com/SRLSuperUser/superusers-karamja-fisher' +
    '/master/version'
  );

  if version_remote = '' then begin
    MessageBox('Cannot access GitHub. Please make sure you have OpenSSL insta' +
      'lled on your system', 'Error', 0);

    TerminateScript();
  end

  if not (VERSION = version_remote) then begin
    source := GetPage(
      'https://raw.githubusercontent.com/SRLSuperUser/superusers-karamja-fish' +
      'er/master/superusers-karamja-fisher.simba'
    );

    try
      fh := ReWritefile(ScriptPath + 'superusers-karamja-fisher.simba', true);

      WriteFileString(fh, source);

      MessageBox(
        'Successfully updated SuperUser''s Karamja Fisher to v' +
        version_remote + '!' + Chr(13) + Chr(13) + ' Please reload the script.',
        'Success',
        0
      );

      TerminateScript();
    except
      MessageBox('An error occurred while trying to update!', 'Error', 0);
    finally
      CloseFile(fh);
    end
  end
end

procedure Initialize()
var
  i: integer;
begin
  ClearDebug();

  disableSRLDebug := true;
  currentPlayer := 0;
  smartPlugins := ['d3d9.dll'];
  smartEnableDrawing := true;

  with playerform do begin
    name := 'SuperUser''s Karamja Fisher';
    scriptHelpThread := 'http://villavu.com/forum/showthread.php?t=';
    scriptSettingsPath := AppPath + 'Scripts/superusers-karamja-fisher.txt';

    comboBoxLabels := ['Fish type'];
    comboBoxDefaults := ['Lobster'];
    comboBoxItems := [['Lobster', 'Tuna / Swordfish']];

    checkBoxLabels := ['Show SRL debug'];
    checkBoxDefaults := ['false'];
  end

  RunPlayerForm();

  players.setup(playerForm.playerNames, playerForm.playerFile);

  SetupSRL();

  for i := 0 to high(players) do
    with players[i] do begin
      booleans[0] := StrToBool(
        playerForm.players[i].settings[0]
      );

      strings[1] := playerForm.players[i].settings[1]; // Fish type
    end

  currentPlayer := 0;

  players[currentPlayer].isActive := true;
  players[currentPlayer].Configure();

  SUSSetup();

  SUSAddObject('Fishing spot')
    ^.CreatePart()
      ^.SetColorData(3, 12495003, 43, 0.0, 0.0, 0.50)
      ^.SetSize([2, 2, 155, 155])
      ^.SetMaxDistance(200)
      ^.SetStep(6)
      ^.SetAnti(false)
      ^.SetMinPixelCount(6);

  with SUSAddObject('Stiles')^ do begin
    CreatePart()
      ^.SetColorData(2, 10066856, 13, 0.26, 0.37)
      ^.SetSize([3, 3, 65, 65])
      ^.SetMaxDistance(200)
      ^.SetStep(12)
      ^.SetAnti(false)
      ^.SetMinPixelCount(10);

    CreatePart()
      ^.SetColorData(3, 3421753, 12, 0.0, 0.0, 0.50)
      ^.SetSize([2, 2, 65, 65])
      ^.SetMaxDistance(200)
      ^.SetStep(10)
      ^.SetAnti(false)
      ^.SetMinPixelCount(5);
  end

  AssertSPSMap(
    'Includes/SPS/img',
    'https://github.com/SRLSuperUser/superusers-karamja-fisher/blob/master/re' +
    'sources/sps',
    'su-kf-karamja',
    '5A2D88922839F922B19DA87E6CE4D7C39D400608'
  );

  karamja.setup(
    'su-kf-karamja',
    '',
    __DEFAULT_ACCURACY,
    __DEFAULT_TOLERANCE,
    0.7
  );

  SetLength(walking_paths, 5);

  walking_paths[0] := [
    Point(589, 119), Point(587, 130), Point(579, 133), Point(561, 137),
    Point(542, 137), Point(530, 149), Point(498, 151), Point(482, 157),
    Point(479, 176), Point(477, 188), Point(452, 188), Point(423, 202),
    Point(395, 216), Point(370, 237), Point(357, 251), Point(326, 250),
    Point(306, 262), Point(292, 268), Point(271, 274)];

  walking_paths[1] := [
    Point(588, 117), Point(588, 127), Point(590, 142), Point(564, 153),
    Point(539, 161), Point(521, 148), Point(478, 167), Point(477, 185),
    Point(465, 198), Point(430, 204), Point(406, 219), Point(371, 236),
    Point(333, 247), Point(309, 256), Point(291, 265), Point(270, 276)
  ];

  walking_paths[2] := [
    Point(589, 128), Point(587, 139), Point(568, 153), Point(542, 161),
    Point(511, 151), Point(480, 164), Point(482, 188), Point(478, 210),
    Point(449, 220), Point(406, 229), Point(371, 243), Point(353, 249),
    Point(330, 252), Point(306, 263), Point(285, 267), Point(269, 277)
  ];

  walking_paths[3] := [
    Point(588, 123), Point(591, 130), Point(589, 142), Point(562, 146),
    Point(545, 153), Point(524, 154), Point(485, 158), Point(478, 172),
    Point(476, 189), Point(458, 223), Point(430, 221), Point(401, 221),
    Point(376, 234), Point(349, 248), Point(305, 262), Point(275, 273)
  ];

  walking_paths[4] := [
    Point(588, 126), Point(591, 137), Point(586, 152), Point(574, 159),
    Point(544, 157), Point(529, 150), Point(498, 146), Point(480, 183),
    Point(442, 196), Point(404, 216), Point(367, 239), Point(334, 253),
    Point(296, 261), Point(271, 275)
  ];
end

procedure Uninitialize()
begin

end

procedure Walk(invert: boolean = false)
var
  path: TPointArray;
begin
  path := walking_paths[Random(Length(walking_paths))].Copy();

  if invert then
    path.Invert();

  karamja.WalkPath(path);
end

{**
 * I find it weird this doesn't exist in Simba/SRL-6..
 *
 *}
function TIntegerArray.StdDev(): extended
var
  avg, total: extended;
  i: integer;
begin
  for i := 0 to High(self) do
    total := total + self[i];

  avg := total / Length(self);
  total := 0;

  for i := 0 to High(self) do
    total := total + Pow(self[i] - avg, 2);

  result := Sqrt(total / Length(self));
end

{**
 * Check whether the player is currently fishing.
 * Uses standard deviation with two sigma-confidence.
 *}
function IsFishing(sigmas: integer = 2): boolean
var
  c, i: integer;
  ia: TIntegerArray;
  e: extended;
begin
  SetLength(ia, 10);
  Dec(sigmas);

  c := tabBackpack.Count();
  result := false;

  for i := 0 to High(ia) do begin
    if tabBackpack.IsFull() then
      Exit(false);

    if c <> tabBackpack.Count() then
      Exit(true);

    ia[i] := GetPixelShiftAverage(mainscreen.playerBox, 25, 100);
  end

  e := ia.StdDev();

  if (e < 50) and (sigmas > 0) then
    result := IsFishing(sigmas)
  else
    result := e > 50;
end

procedure Die(const message: string = '')
begin
  WriteLn(message);

  TerminateScript();
end

procedure NoteFish(tries: integer = 5)
var
  c: integer;
  t: TTimeMarker;
begin
  if tries = 0 then
    Die('Cannot note fish');

  Walk();

  c := tabBackpack.Count();

  if SUSGetObject('Stiles')^.Click(
    10,
    MOUSE_RIGHT,
    'xch',
    true,
    true
  ) then begin
    t.Start();

    repeat
      Wait(RandomRange(33, 66));

      if t.GetTime() > 10000 then begin
        NoteFish(tries - 1);

        Exit();
      end
    until c <> tabBackpack.Count();
  end else begin
    NoteFish(tries - 1);

    Exit();
  end

  Walk(true);
end

procedure AntiBan();
begin
  if (not IsLoggedIn()) then
    Exit();

  case Random(600) of
    1: HoverSkill(SKILL_FISHING);
    3: SmallRandomMouse();
    4: RandomRClickItem();
    6: begin
      boredHuman();

      mainscreen.SetAngle(MS_ANGLE_HIGH);
    end
    10..30: minimap.SetAngle(Random(360));
    31..80: MouseRandom(mainscreen.GetBounds().GetRandomPoint(), MOUSE_MOVE);
  end;
end;

procedure DropJunkFish()
var
  shrimp_etc, I: integer;
  pa: TPointArray;
begin
  shrimp_etc := DTMFromString('mlwAAAHicY2dgYFjExMAwH4jnAfFKIN4JxDuAeD0QT2VkY' +
    'JgBxLOg9DQgXgjES4CYgYEJD6YIAABJfgkN');

  with tabBackpack.getBounds() do
    FindDTMs(shrimp_etc, pa, x1, y1, x2, y2);

  for i := 0 to High(pa) do begin
    MouseRandom(pa[i], MOUSE_RIGHT);

    chooseOption.Select(['rop Raw'], 1, 2000);

    Wait(RandomRange(50, 250));
  end

  FreeDtm(shrimp_etc);
end

begin
  Initialize();

  repeat
    Walk(true);

    repeat
      while tabBackpack.Count() < 28 do begin
        if SUSGetObject('Fishing spot')^.Click(
          20,
          MOUSE_LEFT,
          fish_str,
          true,
          true,
          true
        ) then begin
          Wait(1000 + Random(1000));

          while IsFishing() do begin
            Wait(RandomRange(30, 60));

            AntiBan();
          end
        end
      end

      DropJunkFish();

      if tabBackpack.Count() = 28 then
        NoteFish();
    until not IsLoggedIn();

    players[currentPlayer].Configure();
  until false;
end.
